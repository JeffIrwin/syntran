
//==============================================================================

// It might be cleaner to use an array of filenames to toggle these

let input_file = "";
let test_input = not true;
if test_input
	input_file = "test-input.txt";
else
	input_file = "input.txt";

//==============================================================================

// Utility fns

fn countlines(filename: str): i32
{
	let fi = open(filename);
	//println("fi = " + str(fi));

	let nlines = 0;
	while not eof(fi)
	{
		//println(i);
		let str = readln(fi);
		//println("eof syntran = " + str(eof(fi)));
		nlines += 1;
		//println();
	}
	nlines -= 1;
	close(fi);

	let ans = nlines;
}

//==========================================================

fn scan(str_: str, set: str): i32
{
	// c.f. Fortran intrinsic scan()

	//println("str_ = ", str_);
	//println("set = ", set);

	let found = false;
	let i = 0;
	while not found and i < len(str_)
	{

		let j = 0;
		while not found and j < len(set)
		{
			found = str_[i] == set[j];
			j += 1;
		}
		i += 1;
	}

	// return
	if (found)
		i -= 1;
	else
		i = -1;
}

//==========================================================

fn scanback(str_: str, set: str): i32
{
	// c.f. Fortran intrinsic scan() with back = true

	//println("str_ = ", str_);
	//println("set = ", set);

	let found = false;
	let i = len(str_) - 1;
	while not found and i > 0
	{

		let j = 0;
		while not found and j < len(set)
		{
			found = str_[i] == set[j];
			j += 1;
		}
		i -= 1;
	}

	// return
	if (found)
		i += 1;
	else
		i = -1;
}

//==========================================================

fn verify(str_: str, set: str): i32
{
	// c.f. Fortran intrinsic verify()

	//println("str_ = ", str_);
	//println("set = ", set);

	let found = true;
	let i = 0;
	while found and i < len(str_)
	{
		//println(i);

		let j = 0;
		found = false;
		while not found and j < len(set)
		{
			found = str_[i] == set[j];
			j += 1;
		}
		i += 1;
	}

	// return
	if (not found)
		i -= 1;
	else
		i = -1;
}

//==========================================================

fn tok_u32(str_: str): [i32; :]
{
	// tokenize a string into the first *unsigned* int contained within it, then
	// return the substring start index, end index, and length
	//
	// even though syntran doesn't have unsigned ints yet, this is needed
	// bc aoc problems sometimes use "-" as a delimiter (e.g. 2020 day 2)

	//println("starting tok_u32()");
	//println("str_ = ", str_);

	// no negatives
	let nums = "1234567890";
	let beg_ = scan    (str_, nums);

	let end_ = -1;
	let len_ = -1;

	if (beg_ >= 0)
	{

		let n = len(str_);
		//println("n = ", n);
	
		len_ = verify(str_[beg_:n], nums);
		//println("len_ = ", len_);
	
		if (len_ < 0)
		{
			// This is consistent with the way that verify() works in Fortran
			end_ = n - 1;
			len_ = end_ - beg_ + 1;
		}
		else
			end_ = beg_ + len_ - 1;
	
		//println("beg_ = ", beg_);
		//println("end_ = ", end_);
	
		//println("num beg = ", str_[beg_]);
		//println("num end = ", str_[end_]);
		//println("num str = ", str_[beg_: end_+1]);
	}

	// return
	[beg_, end_, len_];
}

//==========================================================

fn parse_u32s(str_: str): [i32; :]
{
	// Parse a vector of *positive* i32 integers from a string.  Any non-int
	// characters are treated as delimiters, including minus `-`

	let i = 0;
	let n = len(str_);

	//println("str_ = ", str_);
	//println("n = ", n);

	let toks = [0, 0, 0];
	let num_nums = 0;  // the number of numbers

	while toks[0] >= 0
	{
		//println("i = ", i);
		toks = tok_u32(str_[i:n]);
		//println("toks = ", toks);
		//let num = i32(str_[i + toks[0]: i + toks[1]+1]);
		//println("num = ", num);
		num_nums += 1;
		i += toks[1] + 1;
	}
	num_nums -= 1;

	let nums = [0; num_nums];
	i = 0;
	for j in [0: num_nums]
	{
		//println("i = ", i);
		toks = tok_u32(str_[i:n]);
		//println("toks = ", toks);
		let num = i32(str_[i + toks[0]: i + toks[1]+1]);
		//println("num = ", num);
		nums[j] = num;
		//num_nums += 1;
		i += toks[1] + 1;
	}
	//println("nums = ", nums);

	// return
	nums;
}

//==============================================================================

fn part1(): i32
{
	let sum_ = 0;

	let f = open(input_file);
	let s = readln(f);
	while not eof(f)
	{
		println("s = ", s);

		let is = 0;
		let ns = len(s);

		let toks = tok_u32(s[is:ns]);
		println("toks = ", toks);

		let num0 = i32(s[is + toks[0]: is + toks[1]+1]);
		is += toks[1] + 1;

		// skip `-` delimiter
		//is += 1; // TODO?

		toks = tok_u32(s[is:ns]);
		let num1 = i32(s[is + toks[0]: is + toks[1]+1]);

		println("nums = ", num0, ", ", num1);

		println();
		s = readln(f);
	}
	close(f);

	println("part1 = ", sum_);
	let ans = sum_;
}

//==============================================================================

fn main(): i32
{
	println("Reading input file """, input_file, """");
	part1();
	//part2();
}

//==============================================================================

main();

//==============================================================================

