
fn mul_mat_vec(mat: [f32; :,:], vec: [f32; :]): [f32; :]
{
	// Matrix-vector multiplication.  Return mat * vec
	//println("starting mul_mat_vec()");
	//let ans =  [0.0; size(mat,0)];
	let n = size(mat,0);
	let ans =  [0.0; n];
	for     j in [0: size(mat,1)]
		for i in [0: size(mat,0)]
			ans[i] = ans[i] + mat[i,j] * vec[j];
	return ans;
}

fn mul_mat(a: [f32; :,:], b: [f32; :,:]): [f32; :,:]
{
	// Matrix-matrix multiplication.  Return a * b
	//println("starting mul_mat()");
	let l = size(a,0);
	//println("l = ", l);
	let m = size(a,1);
	//println("m = ", m);
	let n = size(b,1);
	//println("n = ", n);
	let c = [0.0; l, n];
	for         k in [0: n]
		for     j in [0: m]
			for i in [0: l]
				c[i,k] = c[i,k] + a[i,j] * b[j,k];
	return c;
}

// 3D vector with x = 1.0, y = 2.0, z = 3.0
let vec = [1.0, 2.0, 3.0];

// 3x3 identity matrix.  Sizes go after the semicolon
let eye3 =
	[
		1.0, 0.0, 0.0,
		0.0, 1.0, 0.0,
		0.0, 0.0, 1.0 ;
		3, 3
	];

eye3;

// 90 degree x rotation.  Note that arrays are stored in row-major order, so
// this appears transposed
let rotx =
	[
		1.0,  0.0,  0.0,
		0.0,  0.0,  1.0,
		0.0, -1.0,  0.0 ;
		3, 3
	];

// 90 degree y rotation
let roty =
	[
		0.0,  0.0, -1.0,
		0.0,  1.0,  0.0,
		1.0,  0.0,  0.0 ;
		3, 3
	];

//println(rotx);
//println(roty);

// Apply 180 degree x rotation then 180 degree y rotation, which is equivalent
// to applying a 180 degree z rotation
//println("calling");

//let rotx1 = rotx;
//return mul_mat_vec(mul_mat(mul_mat(mul_mat(rotx, rotx1), roty), roty), vec);

//// TODO: nested fn calls should work
//return mul_mat_vec(mul_mat(mul_mat(mul_mat(rotx, rotx), roty), roty), vec);

let rotxx  = mul_mat(rotx, rotx);
let rotxxy = mul_mat(rotxx, roty);
return mul_mat_vec(mul_mat(rotxxy, roty), vec);

// [-1.0, -2.0, 3.0]

