
// This include file has helper fns for reading ints inside strings mixed with
// other non-integer characters

//==========================================================

fn scan(str_: str, set: str): i64
{
	// c.f. Fortran intrinsic scan()

	//println("str_ = ", str_);
	//println("set = ", set);

	let found = false;
	let i = i64(0);
	while not found and i < len(str_)
	{

		let j = 0;
		while not found and j < len(set)
		{
			found = str_[i] == set[j];
			j += 1;
		}
		i += 1;
	}

	// return
	if (found)
		i -= 1;
	else
		i = i64(-1);
	return i;
}

//==========================================================

fn scanback(str_: str, set: str): i64
{
	// c.f. Fortran intrinsic scan() with back = true

	//println("str_ = ", str_);
	//println("set = ", set);

	let found = false;
	let i = len(str_) - 1;
	while not found and i >= 0
	{

		let j = 0;
		while not found and j < len(set)
		{
			found = str_[i] == set[j];
			j += 1;
		}
		i -= 1;
	}

	// return
	if (found)
		i += 1;
	else
		i = -1;
	return i;
}

//==========================================================

fn verify(str_: str, set: str): i64
{
	// c.f. Fortran intrinsic verify()

	//println("starting verify()");
	//println("str_ = """, str_, """");
	//println("set = ", set);

	let found = true;
	let i = i64(0);
	while found and i < len(str_)
	{
		//println(i);

		let j = 0;
		found = false;
		while not found and j < len(set)
		{
			//found = str_[i] != set[j];
			//found = not (str_[i] == set[j]);
			found = str_[i] == set[j];
			j += 1;
		}
		i += 1;
	}

	// return
	if (not found)
		i -= 1;
	else
		i = i64(-1);
	return i;
}

//==========================================================

fn tok_i32(str_: str): [i64; :]
{
	// tokenize a string into the first int contained within it, then return the
	// substring start index, end index, and length

	//println("starting tok_i32()");
	//println("str_ = """, str_, """");

	let nums = "1234567890";
	let beg_ = scan    (str_, nums);
	//println("beg_ = ", beg_);

	let n = len(str_);
	//println("n = ", n);

	// nasty bug which was just fixed
	let len_ = i64(-1);
	if (beg_ >= 0)
		len_ = verify(str_[beg_:n], nums);
	//println("len_ = ", len_);

	let end_ = i64(-1);
	if (beg_ < 0)
	{
		//println("no beg_");
	}
	else if (len_ < 0)
	{
		// This is consistent with the way that verify() works in Fortran
		end_ = n - 1;
		len_ = end_ - beg_ + 1;
	}
	else
		end_ = beg_ + len_ - 1;

	//println("beg_ = ", beg_);
	//println("end_ = ", end_);

	//println("num beg = ", str_[beg_]);
	//println("num end = ", str_[end_]);
	//println("num str = ", str_[beg_: end_+1]);

	// return
	return [beg_, end_, len_];
}

//==========================================================

fn read_i32(str_: str): i32
{
	let toks = tok_i32(str_);

	// multiple return vals are packed into a vec bc i don't have structs :sad:
	let beg_ = toks[0];
	let end_ = toks[1];
	//let len_ = toks[2]; // not needed

	//println("read_i32 substr = ", str_[beg_: end_+1]);

	let ans = parse_i32(str_[beg_: end_+1]);
	//println("read_i32 = ", ans);

	// return
	return ans;
}

fn read_i32s(str_: str): [i32; :]
{
	// Parse a vector of i32 integers from a string.  Any non-int characters are
	// treated as delimiters

	let i = i64(0);
	let n = len(str_);

	//println("str_ = ", str_);
	//println("n = ", n);

	//let toks = i64([0, 0, 0]);
	let toks = [i64(0); 3];
	let num_nums = 0;  // the number of numbers

	while toks[0] >= 0
	{
		//println("i = ", i);
		toks = tok_i32(str_[i:n]);
		//println("toks = ", toks);
		//println("num = ", num);
		num_nums += 1;
		i += toks[1] + 1;
	}
	num_nums -= 1;

	let nums = [0; num_nums];
	i = i64(0);
	for j in [0: num_nums]
	{
		//println("i = ", i);
		toks = tok_i32(str_[i:n]);
		//println("toks = ", toks);
		let num = parse_i32(str_[i + toks[0]: i + toks[1]+1]);
		//println("num = ", num);
		nums[j] = num;
		//num_nums += 1;
		i += toks[1] + 1;
	}

	// return
	return nums;
}

//==========================================================

